---
title: 动态构建Repository
order: 1
---

## 新建项目
项目一定得是多模块

其中apt处理的模块需要单独一个module因为编译会有依赖关系所以这边是这么建议的

新建两个模块
repo-processor

repo-test

父模块
```xml

    <dependencyManagement>

        <dependencies>

            <dependency>
                <groupId>com.easy-query</groupId>
                <artifactId>sql-processor</artifactId>
                <version>2.0.14</version>
            </dependency>
            <dependency>
                <groupId>com.easy-query</groupId>
                <artifactId>sql-core</artifactId>
                <version>2.0.14</version>
            </dependency>
            <dependency>
                <groupId>com.easy-query</groupId>
                <artifactId>sql-api-proxy</artifactId>
                <version>2.0.14</version>
            </dependency>
            <!-- https://mvnrepository.com/artifact/org.springframework/org.springframework.context -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>5.3.4</version>
                <scope>provided</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

其中repo-test依赖repo-processor

repo-processor
```xml

    <dependencies>
        <dependency>
            <groupId>com.easy-query</groupId>
            <artifactId>sql-api-proxy</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
    </dependencies>

    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*</include>
                </includes>
                <excludes>
                    <exclude>
                        *.properties
                    </exclude>
                </excludes>
            </resource>
            <resource>
                <directory>target/generated-sources</directory>
            </resource>
        </resources>

        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <proc>none</proc>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

## 创建自定义注解
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ProxyRepository {
}

```

## 创建自定义接口
```java
public interface CrudRepository<TProxy extends ProxyEntity<TProxy, T>, T extends ProxyEntityAvailable<T,TProxy>> {
    Class<T> tableClass();
    ApplicationContext getApplicationContext();//万一后续还要别的可以通过这个方法获取
    EntityQueryable<TProxy, T> getQuery();//获取当前的仓储用于查询
}
```

我们这边最终需要实现的接口是这样的

编写SysUserRepository
```java
@ProxyRepository
public interface SysUserRepository extends CrudRepository<SysUserEntityProxy, SysUserEntity> {

}

实现类是
```java

 @Component
public class SysUserRepositoryImpl implements SysUserRepository {
    private final ApplicationContext applicationContext;
    private final EasyEntityQuery easyEntityQuery;

    public SysUserRepositoryImpl(ApplicationContext applicationContext,EasyEntityQuery easyEntityQuery){
        this.applicationContext = applicationContext;
        this.easyEntityQuery = easyEntityQuery;
    }

    @Override
    public Class<SysUserEntity> tableClass() {
        return SysUserEntity.class;
    }

    @Override
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    @Override
    public EntityQueryable<SysUserEntityProxy, SysUserEntity> getQuery() {
        return easyEntityQuery.queryable(tableClass());
    }
}
```

对比这个类和模板差不多我们只需要修改部分地方即可实现

## 新建模板

我们在repo-prcessor模块新建模板

```java

public class AptConstant {

    public static final String PROXY_TEMPLATE = "package @{package};\n" +
            "\n" +
            "@{imports}" +
            "\n" +
            "/**\n" +
            " * this file automatically generated by easy-query, don't modify it\n" +
            " * 当前文件是scf4j自动生成的请不要随意修改\n" +
            " *\n" +
            " * @author scf4j\n" +
            " */\n" +
            " @Component\n" +
            "public class @{classImplName} implements @{classInterfaceName} {\n" +
            "    private final ApplicationContext applicationContext;\n" +
            "    private final EasyEntityQuery easyEntityQuery;\n" +
            "\n" +
            "    public @{classImplName}(ApplicationContext applicationContext,EasyEntityQuery easyEntityQuery){\n" +
            "        this.applicationContext = applicationContext;\n" +
            "        this.easyEntityQuery = easyEntityQuery;\n" +
            "    }\n" +
            "\n" +
            "    @Override\n" +
            "    public Class<@{argClassName}> tableClass() {\n" +
            "        return @{argClassName}.class;\n" +
            "    }\n" +
            "\n" +
            "    @Override\n" +
            "    public ApplicationContext getApplicationContext() {\n" +
            "        return applicationContext;\n" +
            "    }\n" +
            "\n" +
            "    @Override\n" +
            "    public EntityQueryable<@{argClassProxyName}, @{argClassName}> getQuery() {\n" +
            "        return easyEntityQuery.queryable(tableClass());\n" +
            "    }\n" +
            "}";


}

```

模板很简单就是把我们需要替换的地方用占位符进行了占位

## 新建apt处理器
```java

//支持的注解全路径 使用方法来实现这两个保证在高版本上的java中不会出现警告
// @SupportedAnnotationTypes({"com.eq.apt.repo.processor.annotations.ProxyRepository"})
// @SupportedSourceVersion(SourceVersion.RELEASE_8)
public class ProxyRepositoryProcessor extends AbstractProcessor {
    private Filer filer;
    private Elements elementUtils;
    private Types typeUtils;
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        this.filer = processingEnv.getFiler();
        this.elementUtils = processingEnv.getElementUtils();
        this.typeUtils = processingEnv.getTypeUtils();
    }
    @Override
    public Set<String> getSupportedAnnotationTypes() {
        Set<String> supportedAnnotationTypes = new HashSet<>();
        supportedAnnotationTypes.add(ProxyRepository.class.getCanonicalName());
        return supportedAnnotationTypes;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (!roundEnv.processingOver()) {
            // todo:处理一些业务....
        }
        return false;
    }

}

```
我们在resources下新建`META-INF`文件夹在新建`services`文件夹然后在创建一个`javax.annotation.processing.Processor`这个文件内容填写`ProxyRepositoryProcessor`的全路径类名`com.eq.apt.repo.processor.processor.ProxyRepositoryProcessor`

## 编写业务调试
调试apt只需要在右侧`clean`后再`compile`处右键`debug compile`即可

[demo](https://github.com/xuejmnet/repo-apt) https://github.com/xuejmnet/repo-apt


[demo](https://github.com/xuejmnet/repo-apt) https://github.com/xuejmnet/repo-apt


[demo](https://github.com/xuejmnet/repo-apt) https://github.com/xuejmnet/repo-apt



::: tip 说明!!!
> 别忘记resources下的文件还有别忘了把标记`generate sources root`
:::

## 新建用户和仓储
```java

@Table("t_user")
@EntityProxy
public class User implements ProxyEntityAvailable<User , UserProxy> {
    private String id;
    private String name;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}



@ProxyRepository
public interface UserRepository extends CrudRepository<UserProxy, User> {
}

```

clean->build即可再test目录看到我们生成的文件